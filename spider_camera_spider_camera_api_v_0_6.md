# Документація API SpiderCamera (v0.6)

Бібліотека `spider_camera` надає Python-обгортку над C++ ядром (на базі `libcamera`) для високошвидкісного серійного захоплення кадрів (burst capture) у форматі **YUV420**.

Версія **0.6** включає важливі оновлення для стабільності на Raspberry Pi 5, зокрема підтримку апаратного вирівнювання пам'яті (Stride/Padding).

## Головний клас

`spider_camera.SpiderCamera`

Основний клас для керування камерою. Створюється без аргументів.

Приклад використання:

cam = spider_camera.SpiderCamera()

## Керування життєвим циклом (Core Methods)

Ці методи керують автоматом станів камери: `0 (Off) -> 1 (Ready) -> 2 (Streaming)`.

### set_cam(cam_id: int)

Вибирає камеру за індексом.

Параметри:
- `cam_id: int` — індекс камери (зазвичай `0` або `1`).

Примітки:
- Має бути викликано першим, **до** `be_ready()`.
- Після виклику `stop()` вибір камери скидається, і цей метод потрібно викликати знову.

### be_ready()

Ініціалізує камеру, завантажує конфігурацію та виділяє буфери пам'яті.

Особливості v0.6:
- Зчитує апаратний крок рядка (`stride`).

Перехід стану: `0 (Off) -> 1 (Ready)`.

Винятки:
- Кидає `RuntimeError`, якщо камера не вибрана або зайнята.

### go()

Запускає потік захоплення кадрів. Камера починає заповнювати внутрішній кільцевий буфер.

Перехід стану: `1 (Ready) -> 2 (Streaming)`.

Дія:
- Застосовує всі встановлені параметри (`ISO`, `Exposure`, `Focus`).
- Активує GPIO-тригери (якщо увімкнені).

### pause()

Призупиняє запис, **не** звільняючи ресурси камери.

Перехід стану: `2 (Streaming) -> 1 (Ready)`.

### stop()

Повністю зупиняє камеру, звільняє буфери та GPIO-лінію.

Перехід стану: `будь-який -> 0 (Off)`.

Важливо:
- Після `stop()` об'єкт камери «забуває» ID вибраної камери.
- Перед наступним `be_ready()` необхідно знову викликати `set_cam()`.

### get_state() -> int

Повертає поточний стан камери.

Коди станів:
- `0` — Off (вимкнено / не ініціалізовано)
- `1` — Ready (готово до запуску)
- `2` — Streaming (йде запис)
- `4` — Error (помилка)

## Параметри зйомки (Hot Parameters)

Ці методи встановлюють значення, які будуть застосовані під час наступного виклику `go()` або під час активного стріму.

### set_iso(iso: int)

Встановлює чутливість сенсора.

Діапазон:
- `1 – 4000+` (залежить від сенсора).

Логіка:
- Бібліотека автоматично розраховує аналогове підсилення (*Analogue Gain*).

### set_exposure(exposure_us: int)

Встановлює час витримки у мікросекундах.

Приклад:
- `100` → приблизно `1/10000` с.

### set_focus(value: float)

Встановлює позицію лінзи (*Lens Position*).

Діапазон (типово):
- `0.0` — нескінченність
- `20.0+` — макро-діапазон

### set_resolution(width: int, height: int)

Встановлює бажану роздільну здатність кадру.

Приклад:

set_resolution(3840, 2400)

Важливо:
- Зміна роздільної здатності вимагає повного циклу `stop() -> be_ready()`.

## Отримання даних та stride (v0.6 UPDATED)

Це ключовий розділ змін у версії **0.6**.

### get_burst_frames() -> list[numpy.ndarray]

Основний метод для отримання кадрів.

Повертає:
- Список (`list`) об'єктів `numpy.ndarray` (`dtype=uint8`).

Особливості v0.6:
- Кожен масив містить «сирі» дані пам'яті.
- Рядки масиву можуть містити службові байти (*padding*) в кінці.
- Розмір масиву може бути більшим за `width * height * 1.5`.

Поведінка:
- Блокує доступ до буфера.
- Копіює дані у Python.
- Очищує чергу на стороні C++.

### get_frame_properties() -> tuple

Повертає метадані про потік.

Оновлена сигнатура:

(width, height, format_string, stride)

Поля:
- `width (int)` — корисна ширина зображення в пікселях.
- `height (int)` — корисна висота зображення.
- `format_string (str)` — назва формату (наприклад, `"YUV420"`).
- `stride (int)` — крок рядка в байтах (включаючи *padding*).

Призначення:
- Значення `stride` є критично необхідним для правильного `reshape` зображення.
- Ігнорування `stride` призведе до ефекту «зеленого екрану» або зсуву зображення по діагоналі.

## Алгоритм обробки даних (Data Processing Guide)

У версії **0.6** використовується підхід *Raw Memory Copy*, тому проста операція `reshape((height, width))` **більше не працює коректно**.

Правильний алгоритм обробки кадру:

1. Отримати параметри:

   width, height, fmt, stride = cam.get_frame_properties()

2. Отримати «плоский» буфер:

   flat_frame = frames[i]  # елемент зі списку get_burst_frames()

3. Розрахувати кількість рядків у буфері:

   rows = flat_frame.size // stride

4. Зробити `reshape` з урахуванням stride:

   view_2d = flat_frame[:rows * stride].reshape((rows, stride))

5. Обрізати (crop) зайві дані:

   - Для формату `YUV420` корисна висота для повного кадру YUV: `yuv_height = int(height * 1.5)`
   - Обрізання:

     image = view_2d[:yuv_height, :width]

6. Створити суцільний масив (сумісний з OpenCV):

   image_contiguous = np.ascontiguousarray(image)

7. Конвертувати кольори в BGR (для OpenCV):

   bgr = cv2.cvtColor(image_contiguous, cv2.COLOR_YUV2BGR_I420)

## Синхронізація (GPIO Trigger)

Модуль дозволяє синхронізувати камеру з зовнішнім освітленням чи іншими пристроями.

### set_frame_trigger_pin(pin_num: int)

Налаштовує GPIO-пін (BCM).

Особливості на Raspberry Pi 5:
- Автоматично вибирається правильний контролер (`gpiochip4`).

Вимоги:
- Викликати **до** `be_ready()`.

### enable_frame_trigger(enable: bool)

Вмикає або вимикає генерацію імпульсів.

Рівні сигналу:
- `LOW` — кінець експозиції кадру.
- `HIGH` — готовність до наступного кадру (Start of Capture / початок серії запитів).

## Налагодження

### enable_debug(enable: bool)

Вмикає вивід логів C++ у консоль.

Призначення:
- Моніторинг частоти кадрів (FPS).
- Виявлення пропусків кадрів.
- Діагностика помилок конфігурації або доступу до камери.
